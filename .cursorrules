# Global Cursor Rules - Terrace Project

## Agent System Overview
This project uses a multi-agent system where specialized Claude agents handle different aspects of development. All agents MUST follow these global rules.

## Core Principles

### 1. Scope Restriction
- Agents can ONLY modify files within this project directory
- NO CI/CD management or repository operations (git push, pull requests, etc.)
- NO external system modifications

### 2. Cursor Rules Maintenance
- **CRITICAL**: All agents must keep .cursorrules files up to date in their respective directories
- When changing architecture, patterns, or conventions, UPDATE the relevant .cursorrules
- Check for .cursorrules in the current directory before making significant changes
- If a .cursorrules file contradicts these global rules, global rules take precedence

### 3. Technology Stack
- **Backend**: NestJS with TypeScript (all agents MUST be NestJS experts)
- **Database**: PostgreSQL with TypeORM
- **Frontend**: React with TypeScript and Vite
- **Runtime**: Bun (for scripts and package management)
- **Process Manager**: mprocs (backend and frontend run concurrently)
- **E2E Testing**: Playwright with MCP browser access
- **Graph Models**: Facts/Corpuses domain model with parent-child corpus hierarchy

### 4. Domain Model: Facts, Corpuses, and Context (CRITICAL)
**Corpuses**: Collections of Facts grouped within Projects
- Each Corpus belongs to exactly one Project
- Corpuses form a parent-child hierarchy via `basis_corpus_id`
- When creating a new Corpus, it auto-assigns as child of last Corpus in project (if exists)

**Facts**: Statements contained within Corpuses with context field (NEW)
- Each Fact belongs to exactly one Corpus (`corpus_id`)
- Each Fact has a context field: CORPUS_GLOBAL, CORPUS_BUILDER, or CORPUS_KNOWLEDGE (default)
- Facts have optional basis Fact from parent Corpus (`basis_id`) - SUBJECT TO CONTEXT RULES
- Facts can support other Facts in same Corpus via `fact_support` junction table - SUBJECT TO CONTEXT RULES
- Facts have a state machine: CLARIFY (no statement), CONFLICT, READY, REJECTED, CONFIRMED
- Auto-transitions to CLARIFY when statement is empty or null
- Flexible metadata stored as JSONB (`meta` column)

**Context-Specific Constraints** (MANDATORY - enforced at multiple layers):
- **CORPUS_GLOBAL** (foundation facts): Cannot have basis (`basis_id` MUST be null), can only support other GLOBAL facts
- **CORPUS_BUILDER** (generation guidelines): Cannot have basis (`basis_id` MUST be null), can only support other BUILDER facts
- **CORPUS_KNOWLEDGE** (knowledge base): Can have basis only from parent corpus KNOWLEDGE facts, can only support other KNOWLEDGE facts

**Database Validation Triggers** (defined in migration 1700000000000-CreateTriggers.ts):
- `set_fact_state_on_empty_statement()`: Auto-set Fact state to CLARIFY if statement null/empty
- `validate_fact_basis()`: Enforce basis Fact must belong to parent Corpus AND context constraints
- `validate_fact_support()`: Enforce support relationships within same Corpus AND context constraints
- `validate_fact_context()`: NEW - Enforce context-specific basis/support rules
- `decouple_fact_relationships_on_corpus_change()`: Clear relationships when Fact changes Corpus

These constraints are enforced at database level AND must be validated in business logic AND API validation.

### 5. Code Quality Standards
- Use TypeScript strict mode
- Follow functional programming principles where appropriate
- Prefer composition over inheritance
- Write self-documenting code with clear naming
- Add JSDoc comments for public APIs and complex logic
- Use async/await over Promise chains
- Handle errors explicitly - no silent failures
- Respect database-level validation constraints (triggers) in application logic
- Validate Fact basis belongs to parent Corpus before database operations
- Validate support relationships within same Corpus before database operations

### 6. File Organization
```
terrace/
├── backend/          # NestJS API (REST API Agent, DB Agent, Business Logic Agent)
│   ├── src/
│   │   ├── modules/fact/       # Fact CRUD operations
│   │   ├── modules/corpus/     # Corpus CRUD operations
│   │   └── entities/           # TypeORM entities (Fact, Corpus, etc.)
│   │   └── migrations/         # Database migrations including triggers
├── frontend/         # React UI (Frontend Architect Agent)
├── scripts/          # Bun scripts (DevOps Agent)
├── docs/             # Documentation (Project Manager Agent)
└── .claude/agents/   # Agent definitions (specialized sub-agents)
```

### 7. Testing Requirements

**Development Environment**:
- Server is ALWAYS assumed to be running via `bun run dev` (mprocs)
- Backend runs at `http://localhost:3000`
- Frontend runs at `http://localhost:5173`
- Tests should be single-run commands that execute against the live server

**Test Types**:
- **Unit Tests**: Write for business logic, services, and utilities
- **Integration Tests**: Write for API endpoints (test against running server)
- **E2E Tests**: Use Playwright with MCP browser access
- **Fact/Corpus Tests**: Test state machine transitions, relationships
- Mock external dependencies only (not internal services)

**E2E Testing with Playwright**:
- Agents have MCP browser access for interactive testing
- Tests run against live development server
- Use `bun run test:e2e` for headless tests
- Use `bun run test:e2e:ui` for interactive UI mode
- Tests validate full user flows and API integration
- Test Fact creation, state transitions, and relationship management

### 8. Database & ORM Guidelines
- All Fact/Corpus data MUST use proper relational models via TypeORM
- Facts and Corpuses should have dedicated tables with proper relationships
- Use TypeORM decorators properly (ManyToOne, OneToMany, ManyToMany)
- Include migrations for all schema changes
- Index frequently queried fields (corpusId, basisId, state, projectId)
- Database triggers enforce validation (see migration 1700000000000-CreateTriggers.ts)
- Understand trigger constraints before writing business logic

### 9. API Design
- Follow RESTful conventions
- Use proper HTTP status codes
- Validate input with class-validator
- Return consistent error formats
- Version APIs when breaking changes occur
- **Fact/Corpus Endpoints**:
  - `GET /facts` - List facts (paginated, filterable)
  - `POST /facts` - Create fact (validates basis/corpus)
  - `PATCH /facts/:id` - Update fact (validates basis/support)
  - `DELETE /facts/:id` - Delete fact
  - `POST /facts/:id/support` - Add support relationship
  - `DELETE /facts/:id/support/:supportFactId` - Remove support
  - `GET /corpuses` - List corpuses
  - `POST /corpuses` - Create corpus (auto-assigns parent)
  - `PATCH /corpuses/:id` - Update corpus
  - `DELETE /corpuses/:id` - Delete corpus

### 10. React & Frontend
- Use functional components with hooks
- Implement proper error boundaries
- Use TypeScript interfaces for all props
- Keep components small and focused
- Separate business logic from presentation
- **Display Fact state**: Use FactState enum values (CLARIFY, CONFLICT, READY, REJECTED, CONFIRMED)
- **Show Fact relationships**: Display basis fact and support facts
- **Handle Corpus hierarchy**: Show parent/child relationships

### 11. Documentation
- Update README.md files when changing project structure
- Document all environment variables
- Maintain API documentation
- Keep agent responsibilities documented
- **Document Fact/Corpus model** in architecture docs
- **Document database triggers** and their constraints
- **Document state machine** for Facts

## Agent Interaction Protocol

### Before Making Changes
1. Read the local .cursorrules for your domain
2. Understand existing patterns in the codebase
3. Check if changes affect other agent domains

### After Making Changes
1. Update relevant .cursorrules if patterns changed
2. Update documentation if public APIs changed
3. Update tests to reflect changes
4. Create a git commit with a concise 1-5 sentence summary

### Cross-Agent Communication
- Agents work independently but follow shared conventions
- Changes that affect multiple domains should be documented in commit message
- Breaking changes must be highlighted in commit messages

### Completing Tasks
When all tasks are complete:
1. Create a git commit summarizing changes (1-5 sentences)
2. DO NOT write summary files, changelogs, or accomplishment documents
3. Save tokens by keeping output concise

## Prohibited Actions
- ❌ Modifying files outside this project
- ❌ Running git push or CI/CD operations
- ❌ Installing global dependencies
- ❌ Modifying system configurations
- ❌ Ignoring TypeScript errors
- ❌ Committing without updating relevant .cursorrules
- ❌ Writing summary files, changelogs, or accomplishment documents
- ❌ Creating SUMMARY.md, CHANGELOG.md, or similar files after completing work

## Development Workflow

### Running the Application
- **Start all services**: `bun run dev` (uses mprocs)
- **mprocs** manages backend and frontend concurrently
- Backend and frontend auto-reload on file changes
- Tests assume servers are running

### Testing Strategy
- **Unit/Integration Tests**: Run with `bun run test` (single execution)
- **E2E Tests**: Run with `bun run test:e2e` (Playwright against live server)
- **Interactive E2E**: Use `bun run test:e2e:ui` for debugging
- **Validation**: Agents can use MCP browser to test features interactively

### NestJS Expertise Required
All agents working with backend code MUST:
- Understand NestJS module system and dependency injection
- Know decorators: `@Controller`, `@Injectable`, `@Module`, etc.
- Follow NestJS best practices for services, controllers, and providers
- Understand NestJS lifecycle hooks and middleware
- Know how to use NestJS testing utilities

## Required Actions
- ✅ Keep .cursorrules synchronized with code
- ✅ Write TypeScript with strict typing
- ✅ Test Fact/Corpus operations thoroughly
- ✅ Test state machine transitions
- ✅ Test relationship constraints (basis, support)
- ✅ Document public APIs
- ✅ Follow the DRY principle
- ✅ Use semantic naming
- ✅ Handle errors gracefully
- ✅ Be a NestJS expert (for backend agents)
- ✅ Understand database triggers and constraints
- ✅ Validate Fact/Corpus relationships before database operations
- ✅ Assume servers are running when testing
- ✅ Create git commits with concise summaries (1-5 sentences)
- ✅ Avoid writing summary files to save tokens

## Key Domain Concepts
- **Fact**: Statement with state machine, context field, optional basis from parent Corpus, can support other Facts
- **Context**: CORPUS_GLOBAL (foundation), CORPUS_BUILDER (generation), CORPUS_KNOWLEDGE (knowledge base) - CRITICAL
- **Corpus**: Collection of Facts with optional parent Corpus, belongs to Project
- **State**: CLARIFY (no statement), CONFLICT, READY, REJECTED, CONFIRMED
- **Basis**: Optional parent Fact from parent Corpus (context-aware validation via trigger)
- **Support**: Many-to-many relationships between Facts in same Corpus with same context (validates via trigger)
- **Trigger**: Database-level constraint enforcement (5 triggers including new context validation trigger)
- **Context Constraint**: GLOBAL/BUILDER cannot have basis, can only support same-context facts; KNOWLEDGE can have basis from parent KNOWLEDGE facts
